{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/web/silly/silly/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/web/silly/silly/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"D:/web/silly/silly/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"D:/web/silly/silly/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar Mixin = require('../../utils/mixin');\n\nvar Tokenizer = require('../../tokenizer');\n\nvar LocationInfoTokenizerMixin = require('./tokenizer-mixin');\n\nvar LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\n\nvar HTML = require('../../common/html'); //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nvar LocationInfoParserMixin = /*#__PURE__*/function (_Mixin) {\n  _inherits(LocationInfoParserMixin, _Mixin);\n\n  var _super = _createSuper(LocationInfoParserMixin);\n\n  function LocationInfoParserMixin(parser) {\n    var _this;\n\n    _classCallCheck(this, LocationInfoParserMixin);\n\n    _this = _super.call(this, parser);\n    _this.parser = parser;\n    _this.treeAdapter = _this.parser.treeAdapter;\n    _this.posTracker = null;\n    _this.lastStartTagToken = null;\n    _this.lastFosterParentingLocation = null;\n    _this.currentToken = null;\n    return _this;\n  }\n\n  _createClass(LocationInfoParserMixin, [{\n    key: \"_setStartLocation\",\n    value: function _setStartLocation(element) {\n      var loc = null;\n\n      if (this.lastStartTagToken) {\n        loc = Object.assign({}, this.lastStartTagToken.location);\n        loc.startTag = this.lastStartTagToken.location;\n      }\n\n      this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n  }, {\n    key: \"_setEndLocation\",\n    value: function _setEndLocation(element, closingToken) {\n      var loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n      if (loc) {\n        if (closingToken.location) {\n          var ctLoc = closingToken.location;\n          var tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n          // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n          var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n          var endLoc = {};\n\n          if (isClosingEndTag) {\n            endLoc.endTag = Object.assign({}, ctLoc);\n            endLoc.endLine = ctLoc.endLine;\n            endLoc.endCol = ctLoc.endCol;\n            endLoc.endOffset = ctLoc.endOffset;\n          } else {\n            endLoc.endLine = ctLoc.startLine;\n            endLoc.endCol = ctLoc.startCol;\n            endLoc.endOffset = ctLoc.startOffset;\n          }\n\n          this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n        }\n      }\n    }\n  }, {\n    key: \"_getOverriddenMethods\",\n    value: function _getOverriddenMethods(mxn, orig) {\n      return {\n        _bootstrap: function _bootstrap(document, fragmentContext) {\n          orig._bootstrap.call(this, document, fragmentContext);\n\n          mxn.lastStartTagToken = null;\n          mxn.lastFosterParentingLocation = null;\n          mxn.currentToken = null;\n          var tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n          mxn.posTracker = tokenizerMixin.posTracker;\n          Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n            onItemPop: function onItemPop(element) {\n              mxn._setEndLocation(element, mxn.currentToken);\n            }\n          });\n        },\n        _runParsingLoop: function _runParsingLoop(scriptHandler) {\n          orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n          // that remains on open element stack\n\n\n          for (var i = this.openElements.stackTop; i >= 0; i--) {\n            mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n          }\n        },\n        //Token processing\n        _processTokenInForeignContent: function _processTokenInForeignContent(token) {\n          mxn.currentToken = token;\n\n          orig._processTokenInForeignContent.call(this, token);\n        },\n        _processToken: function _processToken(token) {\n          mxn.currentToken = token;\n\n          orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n          //their end location explicitly.\n\n\n          var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n          if (requireExplicitUpdate) {\n            for (var i = this.openElements.stackTop; i >= 0; i--) {\n              var element = this.openElements.items[i];\n\n              if (this.treeAdapter.getTagName(element) === token.tagName) {\n                mxn._setEndLocation(element, token);\n\n                break;\n              }\n            }\n          }\n        },\n        //Doctype\n        _setDocumentType: function _setDocumentType(token) {\n          orig._setDocumentType.call(this, token);\n\n          var documentChildren = this.treeAdapter.getChildNodes(this.document);\n          var cnLength = documentChildren.length;\n\n          for (var i = 0; i < cnLength; i++) {\n            var node = documentChildren[i];\n\n            if (this.treeAdapter.isDocumentTypeNode(node)) {\n              this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n              break;\n            }\n          }\n        },\n        //Elements\n        _attachElementToTree: function _attachElementToTree(element) {\n          //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n          //So we will use token location stored in this methods for the element.\n          mxn._setStartLocation(element);\n\n          mxn.lastStartTagToken = null;\n\n          orig._attachElementToTree.call(this, element);\n        },\n        _appendElement: function _appendElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._appendElement.call(this, token, namespaceURI);\n        },\n        _insertElement: function _insertElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertElement.call(this, token, namespaceURI);\n        },\n        _insertTemplate: function _insertTemplate(token) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertTemplate.call(this, token);\n\n          var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n        },\n        _insertFakeRootElement: function _insertFakeRootElement() {\n          orig._insertFakeRootElement.call(this);\n\n          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n        },\n        //Comments\n        _appendCommentNode: function _appendCommentNode(token, parent) {\n          orig._appendCommentNode.call(this, token, parent);\n\n          var children = this.treeAdapter.getChildNodes(parent);\n          var commentNode = children[children.length - 1];\n          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n        },\n        //Text\n        _findFosterParentingLocation: function _findFosterParentingLocation() {\n          //NOTE: store last foster parenting location, so we will be able to find inserted text\n          //in case of foster parenting\n          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n          return mxn.lastFosterParentingLocation;\n        },\n        _insertCharacters: function _insertCharacters(token) {\n          orig._insertCharacters.call(this, token);\n\n          var hasFosterParent = this._shouldFosterParentOnInsertion();\n\n          var parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n          var siblings = this.treeAdapter.getChildNodes(parent);\n          var textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n          var textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n          var tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n          if (tnLoc) {\n            var _token$location = token.location,\n                endLine = _token$location.endLine,\n                endCol = _token$location.endCol,\n                endOffset = _token$location.endOffset;\n            this.treeAdapter.updateNodeSourceCodeLocation(textNode, {\n              endLine: endLine,\n              endCol: endCol,\n              endOffset: endOffset\n            });\n          } else {\n            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n          }\n        }\n      };\n    }\n  }]);\n\n  return LocationInfoParserMixin;\n}(Mixin);\n\nmodule.exports = LocationInfoParserMixin;","map":{"version":3,"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","LocationInfoOpenElementStackMixin","HTML","$","TAG_NAMES","LocationInfoParserMixin","parser","treeAdapter","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","element","loc","Object","assign","location","startTag","setNodeSourceCodeLocation","closingToken","getNodeSourceCodeLocation","ctLoc","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endLoc","endTag","endLine","endCol","endOffset","startLine","startCol","startOffset","updateNodeSourceCodeLocation","mxn","orig","_bootstrap","document","fragmentContext","call","tokenizerMixin","install","tokenizer","openElements","onItemPop","_setEndLocation","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_setStartLocation","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode","tnLoc","module","exports"],"sources":["D:/web/silly/silly/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n                const endLoc = {};\n                if (isClosingEndTag) {\n                    endLoc.endTag = Object.assign({}, ctLoc);\n                    endLoc.endLine = ctLoc.endLine;\n                    endLoc.endCol = ctLoc.endCol;\n                    endLoc.endOffset = ctLoc.endOffset;\n                } else {\n                    endLoc.endLine = ctLoc.startLine;\n                    endLoc.endCol = ctLoc.startCol;\n                    endLoc.endOffset = ctLoc.startOffset;\n                }\n\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    const { endLine, endCol, endOffset } = token.location;\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}